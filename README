Backdoor that gives you a scala shell over ssh on your jvm

NOTE: The shell is not sandboxed, anyone access the shell can touch
anything in the jvm and do anything the jvm can do including modifying
and deleting files, etc. Use at your own risk. No guarantees are made
regarding this being secure.

Embed this in your code by running the following:

    val sshd = new ScalaSshShell(port=4444, name="test", user="user",
                                 passwd="fluke",
                                 keysResourcePath=Some("/test.ssh.keys"))

Most of that should be self explanatory. The 'name' is the name that
will be used for the parent thread, as well as the name that will
appear in the prompt that the user sees. A good idea is to name it
after the service the jvm is providing so if the user sshes into the
wrong jvm they'll immediately see a visual indication that they aren't
where they expected to be.

To shut down ssh service, call:

    sshd.stop()

To generate your keys run ScalaSshShell.generateKeys(), which can be
done from a scala shell:

    scala> peak6.util.ScalaSshShell.generateKey("src/main/resources/test.ssh.keys")

Note that the shell does not work when running under sbt's console.
